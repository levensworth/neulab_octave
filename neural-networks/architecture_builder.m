# se tiene un conjunto de puntos para el cual tratamos de hacer la # mejor red neuronal que generalice# variables que se pueden modificar:# eta# momentum# weight decay# source('NeuralNet.m');# entrena a los agentes y luego los testea para ver cual es los mas aptosfunction scored_population = natural_selection(train_input, train_output, test_input, test_output, population, crossover_rate)  scored_population = cell(1,size(population)(2));  # entrenar los agentes  for i = [1 : size(population)(2)]        population{i} = fit(train_input, train_output, population{i}.net);        error = epoch_error(test_output,  feed(test_input, population{i}));        agent.net = population{i};        agent.error = error;        scored_population{i} = agent;  endforendfunctionfunction population = create_population(NetConfig, population_size)  population = cell(1, 0);  for i = [i : population_size]    population{end+1}.net = create(NetConfig);    endforendfunctionfunction next_generation = breeding(scored_population, population_crossover)  next_generation = cell(1,0);  size = max(floor(size(scored_population)(2) * population_crossover), 1);  for i = [1 : size]    [next_generation{end+1}, scored_population] = find_next(scored_population);  endfor  #disp(next_generation);  next_generation = crossover(next_generation);  next_generation = mutation(next_generation);endfunction function [agent, agents] = find_next(agents)  global best;  for i = [1 : size(agents)(2)]    if(agents{i}.error > 0 && (best.error > agents{i}.error || best.error < 0))      best = agents{i};      agents{i}.error = -1;    endif  endfor  agent = best;  endfunction  function next_generation = crossover(generation)  next_generation = cell(1,0);  for i = [1 : size(generation)(2) - 1]    agent = generation{i};    #disp(agent);    agent.momentum = generation{i+1}.net.momentum;    agent.weight_decay = generation{i+1}.net.weight_decay;    agent.error_vec = [];    next_generation{end + 1} =  agent;  endforendfunction    function next_generation = mutation(next_generation)    #shuffle entries    next_generation = next_generation(randperm(numel(next_generation)));    #printf("this is size %d\n", size(next_generation)(2));    for i = [1 : size(next_generation)(2)];      next_generation{i}.net.eta += rand * ((-1) ^ (rand  * 2));      next_generation{i}.net.momentum += rand * ((-1) ^ (rand  * 2));      next_generation{i}.net.weight_decay += rand * ((-1) ^ (rand  * 2));    endforendfunction    global best;best.error = -1;function NeuralNets =  build_architecture(NetConfig, test_input, test_output, train_input, train_output,fitness_epsilon=0.001, population_size=10, population_crossover=0.5)  population = create_population(NetConfig, population_size);  max_epoch  = 10;  epoch = 0;  global best;  do    epoch += 1;    scored_population = natural_selection(train_input, train_output,test_input, test_output, population, population_crossover);    population = breeding(scored_population, population_crossover);    best = find_next(scored_population);    NeuralNets = best;  until(best.error > 0 && best.error < fitness_epsilon || epoch > max_epoch)endfunction# run the algorithmnet =  build_architecture(NetConfig, test_set(:, 1:2), test_set(:,3), training_set(:,1:2), training_set(:,3), 0.0001, 3, 0.5); 